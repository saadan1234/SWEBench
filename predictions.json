[
    {
        "instance_id": "astropy__astropy-11693",
        "model_patch": "Repo: astropy/astropy\nPatch:\ndiff --git a/astropy/wcs/wcsapi/fitswcs.py b/astropy/wcs/wcsapi/fitswcs.py\n--- a/astropy/wcs/wcsapi/fitswcs.py\n+++ b/astropy/wcs/wcsapi/fitswcs.py\n@@ -323,7 +323,17 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world_arrays, 0)\n+\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n@@ -341,7 +351,7 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world_arrays, 0)\n+\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n@@ -359,7 +369,7 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world_arrays, 0)\n+\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n@@ -377,7 +387,7 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world_arrays, 0)\n+\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n@@ -395,7 +405,7 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world_arrays, 0)\n+\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n@@ -413,7 +423,7 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world_arrays, 0)\n+\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n@@ -431,7 +441,7 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        # avoid circular import\n+        from astropy.wcs.wcs import NoConvergence\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence as e:\n+            warnings.warn(str(e))\n+            # use best_solution contained in the exception and format the same\n+            # way as all_world2pix does (using _array_converter)\n+            pixel = self._array_converter(lambda *args: e.best_solution,\n+                                         'input', *world",
        "model_name_or_path": "TinyLlama/TinyLlama-1.1B-Chat-v1.0"
    },
    {
        "instance_id": "astropy__astropy-12057",
        "model_patch": "Repo: astropy/astropy\nPatch:\ndiff --git a/astropy/nddata/nduncertainty.py b/astropy/nddata/nduncertainty.py\n--- a/astropy/nddata/nduncertainty.py\n+++ b/astropy/nddata/nduncertainty.py\n@@ -395,6 +395,40 @@ def _propagate_multiply(self, other_uncert, result_data, correlation):\n     def _propagate_divide(self, other_uncert, result_data, correlation):\n         return None\n \n+    def represent_as(self, other_uncert):\n+        \"\"\"Convert this uncertainty to a different uncertainty type.\n+\n+        Parameters\n+        ----------\n+        other_uncert : `NDUncertainty` subclass\n+            The `NDUncertainty` subclass to convert to.\n+\n+        Returns\n+        -------\n+        resulting_uncertainty : `NDUncertainty` instance\n+            An instance of ``other_uncert`` subclass containing the uncertainty\n+            converted to the new uncertainty type.\n+\n+        Raises\n+        ------\n+        TypeError\n+            If either the initial or final subclasses do not support\n+            conversion, a `TypeError` is raised.\n+        \"\"\"\n+        as_variance = getattr(self, \"_convert_to_variance\", None)\n+        if as_variance is None:\n+            raise TypeError(\n+                f\"{type(self)} does not support conversion to another \"\n+                \"uncertainty type.\"\n+            )\n+        from_variance = getattr(other_uncert, \"_convert_from_variance\", None)\n+        if from_variance is None:\n+            raise TypeError(\n+                f\"{other_uncert.__name__} does not support conversion from \"\n+                \"another uncertainty type.\"\n+            )\n+        return from_variance(as_variance())\n+\n \n class UnknownUncertainty(NDUncertainty):\n     \"\"\"This class implements any unknown uncertainty type.\n@@ -748,6 +782,17 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n     def _data_unit_to_uncertainty_unit(self, value):\n         return value\n \n+    def _convert_to_variance(self):\n+        new_array = None if self.array is None else self.array ** 2\n+        new_unit = None if self.unit is None else self.unit ** 2\n+        return VarianceUncertainty(new_array, unit=new_unit)\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        new_array = None if var_uncert.array is None else var_uncert.array ** (1 / 2)\n+        new_unit = None if var_uncert.unit is None else var_uncert.unit ** (1 / 2)\n+        return cls(new_array, unit=new_unit)\n+\n \n class VarianceUncertainty(_VariancePropagationMixin, NDUncertainty):\n     \"\"\"\n@@ -834,6 +879,13 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n     def _data_unit_to_uncertainty_unit(self, value):\n         return value ** 2\n \n+    def _convert_to_variance(self):\n+        return self\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        return var_uncert\n+\n \n def _inverse(x):\n     \"\"\"Just a simple inverse for use in the InverseVariance\"\"\"\n@@ -933,3 +985,14 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n \n     def _data_unit_to_uncertainty_unit(self, value):\n         return 1 / value ** 2\n+\n+    def _convert_to_variance(self):\n+        new_array = None if self.array is None else 1 / self.array\n+        new_unit = None if self.unit is None else 1 / self.unit\n+        return VarianceUncertainty(new_array, unit=new_unit)\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        new_array = None if var_uncert.array is None else 1 / var_uncert.array\n+        new_unit = None if var_uncert.unit is None else 1 / var_uncert.unit\n+        return cls(new_array, unit=new_unit)\n+\n \n class InverseVarianceUncertainty(_VariancePropagationMixin, NDUncertainty):\n     \"\"\"\n@@ -1008,6 +1060,13 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n     def _data_unit_to_uncertainty_unit(self, value):\n         return value\n \n+    def _convert_to_variance(self):\n+        return self\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        return var_uncert\n+\n \n def _inverse(x):\n     \"\"\"Just a simple inverse for use in the InverseVariance\"\"\"\n@@ -1107,3 +1169,14 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n \n     def _data_unit_to_uncertainty_unit(self, value):\n         return 1 / value ** 2\n+\n+    def _convert_to_variance(self):\n+        new_array = None if self.array is None else 1 / self.array\n+        new_unit = None if self.unit is None else 1 / self.unit\n+        return VarianceUncertainty(new_array, unit=new_unit)\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        new_array = None if var_uncert.array is None else 1 / var_uncert.array\n+        new_unit = None if var_uncert.unit is None else 1 / var_uncert.unit\n+        return cls(new_array, unit=new_unit)\n+\n \n class InverseVariancePropagationMixin(NDUncertaintyPropagationMixin):\n     \"\"\"\n@@ -1210,6 +1272,13 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n     def _data_unit_to_uncertainty_unit(self, value):\n         return value\n \n+    def _convert_to_variance(self):\n+        return self\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        return var_uncert\n+\n \n def _inverse(x):\n     \"\"\"Just a simple inverse for use in the InverseVariance\"\"\"\n@@ -1309,3 +1371,14 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n \n     def _data_unit_to_uncertainty_unit(self, value):\n         return 1 / value ** 2\n+\n+    def _convert_to_variance(self):\n+        new_array = None if self.array is None else 1 / self.array\n+        new_unit = None if self.unit is None else 1 / self.unit\n+        return VarianceUncertainty(new_array, unit=new_unit)\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        new_array = None if var_uncert.array is None else 1 / var_uncert.array\n+        new_unit = None if var_uncert.unit is None else 1 / var_uncert.unit\n+        return cls(new_array, unit=new_unit)\n+\n \n class Inverse",
        "model_name_or_path": "TinyLlama/TinyLlama-1.1B-Chat-v1.0"
    },
    {
        "instance_id": "astropy__astropy-12318",
        "model_patch": "Repo: astropy/astropy\nPatch:\ndiff --git a/astropy/modeling/physical_models.py b/astropy/modeling/physical_models.py\n--- a/astropy/modeling/physical_models.py\n+++ b/astropy/modeling/physical_models.py\n@@ -27,7 +27,12 @@ class BlackBody(Fittable1DModel):\n         Blackbody temperature.\n \n     scale : float or `~astropy.units.Quantity` ['dimensionless']\n-        Scale factor\n+        Scale factor.  If dimensionless, input units will assumed\n+        to be in Hz and output units in (erg / (cm ** 2 * s * Hz * sr).\n+        If not dimensionless, must be equivalent to either\n+        (erg / (cm ** 2 * s * Hz * sr) or erg / (cm ** 2 * s * AA * sr),\n+        in which case the result will be returned in the requested units and\n+        the scale will be stripped of units (with the float value applied).\n \n     Notes\n     -----\n@@ -70,12 +75,40 @@ class BlackBody(Fittable1DModel):\n     scale = Parameter(default=1.0, min=0, description=\"Scale factor\")\n \n     # We allow values without units to be passed when evaluating the model, and\n-    # in this case the input x values are assumed to be frequencies in Hz.\n+    # in this case the input x values are assumed to be frequencies in Hz or wavelengths\n+    # in AA (depending on the choice of output units controlled by units on scale\n+    # and stored in self._output_units during init).\n     _input_units_allow_dimensionless = True\n \n     # We enable the spectral equivalency by default for the spectral axis\n     input_units_equivalencies = {'x': u.spectral()}\n \n+    # Store the native units returned by B_nu equation\n+    _native_units = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)\n+\n+    # Store the base native output units.  If scale is not dimensionless, it\n+    # must be equivalent to one of these.  If equivalent to SLAM, then\n+    # input_units will expect AA for 'x', otherwise Hz.\n+    _native_output_units = {'SNU': u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr),\n+                            'SLAM': u.erg / (u.cm ** 2 * u.s * u.AA * u.sr)}\n+\n+    def __init__(self, *args, **kwargs):\n+        scale = kwargs.get('scale', None)\n+\n+        # Support scale with non-dimensionless unit by stripping the unit and\n+        # storing as self._output_units.\n+        if hasattr(scale, 'unit') and not scale.unit.is_equivalent(u.dimensionless_unscaled):\n+            output_units = scale.unit\n+            if not output_units.is_equivalent(self._native_units, u.spectral_density(1*u.AA)):\n+                raise ValueError(f\"scale units not dimensionless or in surface brightness: {output_units}\")\n+\n+            kwargs['scale'] = scale.value\n+            self._output_units = output_units\n+        else:\n+            self._output_units = self._native_units\n+\n+        return super().__init__(*args, **kwargs)\n+\n     def evaluate(self, x, temperature, scale):\n         \"\"\"Evaluate the model.\n \n@@ -83,7 +116,8 @@ def evaluate(self, x, temperature, scale):\n         ----------\n         x : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['frequency']\n             Frequency at which to compute the blackbody. If no units are given,\n-            this defaults to Hz.\n+            this defaults to Hz (or AA if `scale` was initialized with units\n+            equivalent to erg / (cm ** 2 * s * AA * sr)).\n \n         temperature : float, `~numpy.ndarray`, or `~astropy.units.Quantity`\n             Temperature of the blackbody. If no units are given, this defaults\n@@ -119,30 +153,18 @@ def evaluate(self, x, temperature, scale):\n         else:\n             in_temp = temperature\n \n+        if not isinstance(x, u.Quantity):\n+            # then we assume it has input_units which depends on the\n+            # requested output units (either Hz or AA)\n+            in_x = u.Quantity(x, self.input_units['x'])\n+        else:\n+            in_x = x\n+\n         # Convert to units for calculations, also force double precision\n         with u.add_enabled_equivalencies(u.spectral() + u.temperature()):\n-            freq = u.Quantity(x, u.Hz, dtype=np.float64)\n+            freq = u.Quantity(in_x, u.Hz, dtype=np.float64)\n             temp = u.Quantity(in_temp, u.K)\n \n-        # check the units of scale and setup the output units\n-        bb_unit = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)  # default unit\n-        # use the scale that was used at initialization for determining the units to return\n-        # to support returning the right units when fitting where units are stripped\n-        if hasattr(self.scale, \"unit\") and self.scale.unit is not None:\n-            # check that the units on scale are covertable to surface brightness units\n-            if not self.scale.unit.is_equivalent(bb_unit, u.spectral_density(x)):\n-                raise ValueError(\n-                    f\"scale units not surface brightness: {self.scale.unit}\"\n-                )\n-            # use the scale passed to get the value for scaling\n-            if hasattr(scale, \"unit\"):\n-                mult_scale = scale.value\n-            else:\n-                mult_scale = scale\n-            bb_unit = self.scale.unit\n-        else:\n-            mult_scale = scale\n-\n         # Check if input values are physically possible\n         if np.any(temp < 0):\n             raise ValueError(f\"Temperature should be positive: {temp}\")\n@@ -158,7 +180,17 @@ def evaluate(self, x, temperature, scale):\n         # Calculate blackbody flux\n         bb_nu = 2.0 * const.h * freq ** 3 / (const.c ** 2 * boltzm1) / u.sr\n \n-        y = mult_scale * bb_nu.to(bb_unit, u.spectral_density(freq))\n+        if self.scale.unit is not None:\n+            # Will be dimensionless at this point, but may not be dimensionless_unscaled\n+            if not hasattr(scale, 'unit'):\n+                # during fitting, scale will be passed without units\n+                # but we still need to convert from the input dimensionless\n+                # to dimensionless unscaled\n+                scale = scale * self.scale.unit\n+            scale = scale.to(u.dimensionless_unscaled).value\n+\n+        # NOTE: scale is already stripped of any input units\n+        y = scale * bb_nu.to(self._output_units, u.spectral_density(freq))\n \n         # If the temperature parameter has no unit, we should return a unitless\n         # value. This occurs for instance during fitting, since we drop the\n@@ -169,10 +201,13 @@ def evaluate(self, x, temperature, scale):\n \n     @property\n     def input_units(self):\n-        # The input units are those of the 'x' value, which should always be\n-        # Hz. Because we do this, and because input_units_allow_dimensionless\n-        # is set to True, dimensionless values are assumed to be passed",
        "model_name_or_path": "TinyLlama/TinyLlama-1.1B-Chat-v1.0"
    }
]